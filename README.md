# QxJiaMiCode
关于Android加密哪些事儿 包括hash  MD5 RSA DES等主流加密的原理介绍 和简单示例研究


数据加密又称密码学，它是一门历史悠久的技术，指通过加密算法和加密密钥将明文转变为密文，而解密则是通过解密算法和解密密钥将密文恢复为明文。数据加密目前仍是计算机系统对信息进行保护的一种最可靠的办
　　数据加密又称密码学，它是一门历史悠久的技术，指通过加密算法和加密密钥将明文转变为密文，而解密则是通过解密算法和解密密钥将密文恢复为明文。数据加密目前仍是计算机系统对信息进行保护的一种最可靠的办法。它利用密码技术对信息进行加密，实现信息隐蔽，从而起到保护信息的安全的作用。
一、概述

　　数据加密是指通过加密算法和加密密钥将明文转变为密文，而解密则是通过解密算法和解密密钥将密文恢复为明文。它产生的历史相当久远，它是起源于要追溯于公元前2000年（几个世纪了），虽然它不是现在我们所讲的加密技术（甚至不叫加密），但作为一种加密的概念，确实早在几个世纪前就诞生了。当时埃及人是最先使用特别的象形文字作为信息编码的，随着时间推移，巴比伦、美索不达米亚和希腊文明都开始使用一些方法来保护他们的书面信息。其最基本方法是易位法和置换法。其模型如右图。
　　加密技术包括两个元素：算法和密钥。算法是将普通的文本（或者可以理解的信息）与一串数字（密钥）的结合，产生不可理解的密文的步骤，密钥是用来对数据进行编码和解码的参数。
　　不知不觉中，现实生活中，我们也在使用加密的技术。例如：藏头诗：
　　新雁才闻一两声
　　年年长是惹东风
　　快箭拂下西飞鹏
　　乐不专一须锵铿
　　电报：
　　电报收下来一般都是数码例如一份报是1234 2234 3234…根据手里的密码本用来解密，而且这个密码本是要每隔一定时间就要换一本的，这在事前收发双方就已有约定，什么时间换什么本。 收下一份报，首先要根据另外一份密码把报转成真码，比如1对应2，2对应3…3对应4 原报文处理成如下2345，3345， 4345…当然这只是打比方，然后再利用密码本，根据密码本上的解密方法，比如2345对应“我想”，3345对应“要吃”，4345对应“鸡腿”…合起来就是我想要吃鸡腿，你看这过程中没了密码本，特务即使拿下原报文1234也没办法。
　　这些，都是现实中加密例子。
二、特征

1. 数据保密性　
　　保密性：指防止非法授权用户获得有用信息。现时生活有相应的例子，例如，你要将一个秘密事情告诉别人，故而要将这个事情悄悄的告诉别人。这样能够防止非法用户获取授权。数据加密也是基于这样的特性。
2. 数据完整性
　　完整性：指信息没有被非授权用户更改和破坏，包括信息在生成、传输、存储中不被删除、篡改、伪造等。例如，古代皇帝，下诏的时候，需要笔记和皇英，就是为了保证数据的完整性。
3. 不可抵赖性
不可抵赖性：指实体无法否认或抵赖曾经发送、接受某信息或参与网络信息交互活动的事实。古代的签字画押，也是这样的原理把。
三、常用加密算法比较

1. Hash算法
　　hash算法的意义在于提供了一种快速存取数据的方法,它用一种算法建立键&#20540;与真实&#20540;之间的对应关系,(每一个真实&#20540;只能有一个键&#20540;,但是一个键&#20540;可以对应多个真实&#20540;),这样可以快速在数组等条件中里面存取数据.
2. MD5算法
　　MD5的全称是Message-Digest Algorithm 5（信息-摘要算法），在90年代初由MITLaboratory for Computer Science和RSA Data Security Inc的Ronald L. Rivest开发出来，经MD2、MD3和MD4发展而来。它的作用是让大容量信息在用数字签名软件签署私人密匙前被"压缩"成一种保密的&#26684;式（就是把一个任意长度的字节串变换成一定长的大整数）。不管是MD2、MD4还是MD5，它们都需要获得一个随机长度的信息并产生一个128位的信息摘要。虽然这些算法的结构或多或少有些相&#20284;，但MD2的设计与MD4和MD5完全不同，那是因为MD2是为8位机器做过设计优化的，而MD4和MD5却是面向32位的电脑。这三个算法的描述和C语言源代码在Internet RFCs 1321中有详细的描述（http://www.ietf.org/rfc/rfc1321.txt），这是一份最权威的文档，由Ronald L. Rivest在1992年8月向IEFT提交。
Van Oorschot和Wiener曾经考虑过一个在散列中暴力搜寻冲突的函数（Brute-Force HashFunction），而且他们猜测一个被设计专门用来搜索MD5冲突的机器（这台机器在1994年的制造成本大约是一百万美元）可以平均每24天就找到一个冲突。但单从1991年到2001年这10年间，竟没有出现替代MD5算法的MD6或被叫做其他什么名字的新算法这一点，我们就可以看出这个瑕疵并没有太多的影响MD5的安全性。上面所有这些都不足以成为MD5的在实际应用中的问题。并且，由于MD5算法的使用不需要支付任何版权费用的，所以在一般的情况下（非绝密应用领域。但即便是应用在绝密领域内，MD5也不失为一种非常优秀的中间技术），MD5怎么都应该算得上是非常安全的了。
　　算法的应用
　　MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。比如，在UNIX下有很多软件在下载的时候都有一个文件名相同，文件扩展名为.md5的文件，在这个文件中通常只有一行文本，大致结构如：
MD5 (tanajiya.tar.gz) = 0ca175b9c0f726a831d895e269332461
这就是tanajiya.tar.gz文件的数字签名。MD5将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的MD5信息摘要。如果在以后传播这个文件的过程中，无论文件的内容发生了任何形式的改变（包括人为修改或者下载过程中线路不稳定引起的传输错误等），只要你对这个文件重新计算MD5时就会发现信息摘要不相同，由此可以确定你得到的只是一个不正确的文件。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的"
抵赖"，这就是所谓的数字签名应用。
　　MD5还广泛用于加密和解密技术上。比如在UNIX系统中用户的密码就是以MD5（或其它类&#20284;的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5&#20540;，然后再去和保存在文件系统中的MD5&#20540;进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。
　　正是因为这个原因，现在被黑客使用最多的一种破译密码的方法就是一种被称为"跑字典"的方法。有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用MD5程序计算出这些字典项的MD5&#20540;，然后再用目标的MD5&#20540;在这个字典中检索。我们假设密码的最大长度为8位字节（8 Bytes），同时密码只能是字母和数字，共26&#43;26&#43;10=62个字符，排列组合出的字典的项数则是P(62,1)&#43;P(62,2)….&#43;P(62,8)，那也已经是一个很天文的数字了，存储这个字典就需要TB级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码MD5&#20540;的情况下才可以。这种加密技术被广泛的应用于UNIX系统中，这也是为什么UNIX系统比一般操作系统更为坚固一个重要原因。
　　算法描述
　　对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列&#20540;。
　　在MD5算法中，首先需要对信息进行填充，使其字节长度对512求余的结果等于448。因此，信息的字节长度（Bits Length）将被扩展至N*512&#43;448，即N*64&#43;56个字节（Bytes），N为一个正整数。填充的方法如下，在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。然后，在在这个结果后面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，现在的信息字节长度=N*512&#43;448&#43;64=(N&#43;1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。
　　MD5中有四个32位被称作链接变量（Chaining Variable）的整数参数，他们分别为：A=0x01234567，B=0x89abcdef，C=0xfedcba98，D=0x76543210。
　　当设置好这四个链接变量后，就开始进入算法的四轮循环运算。循环的次数是信息中512位信息分组的数目。
　　将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。
　　主循环有四轮（MD4只有三轮），每轮循环都很相&#20284;。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。
以一下是每次操作中用到的四个非线性函数（每轮一个）。
　　　F(X,Y,Z) =(X&Y)|((~X)&Z)
　　　G(X,Y,Z) =(X&Z)|(Y&(~Z))
　　　H(X,Y,Z) =X^Y^Z
　　　I(X,Y,Z)=Y^(X|(~Z))
　　　（&是与，|是或，~是非，^是异或）
　　这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。
　　假设Mj表示消息的第j个子分组（从0到15），<
　　这四轮（64步）是：
　　第一轮
　　　FF(a,b,c,d,M0,7,0xd76aa478)
　　　FF(d,a,b,c,M1,12,0xe8c7b756)
　　　FF(c,d,a,b,M2,17,0x242070db)
FF(b,c,d,a,M3,22,0xc1bdceee)
　　　FF(a,b,c,d,M4,7,0xf57c0faf)
　　　FF(d,a,b,c,M5,12,0x4787c62a)
　　　FF(c,d,a,b,M6,17,0xa8304613)
　　　FF(b,c,d,a,M7,22,0xfd469501)
　　　FF(a,b,c,d,M8,7,0x698098d8)
　　　FF(d,a,b,c,M9,12,0x8b44f7af)
　　　FF(c,d,a,b,M10,17,0xffff5bb1)
　　　FF(b,c,d,a,M11,22,0x895cd7be)
　　　FF(a,b,c,d,M12,7,0x6b901122)
　　　FF(d,a,b,c,M13,12,0xfd987193)
　　　FF(c,d,a,b,M14,17,0xa679438e)
　　　FF(b,c,d,a,M15,22,0x49b40821)
　　第二轮
　　　GG(a,b,c,d,M1,5,0xf61e2562)
　　　GG(d,a,b,c,M6,9,0xc040b340)
　　　GG(c,d,a,b,M11,14,0x265e5a51)
　　　GG(b,c,d,a,M0,20,0xe9b6c7aa)
　　　GG(a,b,c,d,M5,5,0xd62f105d)
　　　GG(d,a,b,c,M10,9,0x02441453)
　　　GG(c,d,a,b,M15,14,0xd8a1e681)
　　　GG(b,c,d,a,M4,20,0xe7d3fbc8)
　　　GG(a,b,c,d,M9,5,0x21e1cde6)
　　　GG(d,a,b,c,M14,9,0xc33707d6)
　　　GG(c,d,a,b,M3,14,0xf4d50d87)
　　　GG(b,c,d,a,M8,20,0x455a14ed)
　　　GG(a,b,c,d,M13,5,0xa9e3e905)
　　　GG(d,a,b,c,M2,9,0xfcefa3f8)
　　　GG(c,d,a,b,M7,14,0x676f02d9)
　　　GG(b,c,d,a,M12,20,0x8d2a4c8a)
　　第三轮
　　　HH(a,b,c,d,M5,4,0xfffa3942)
　　　HH(d,a,b,c,M8,11,0x8771f681)
　　　HH(c,d,a,b,M11,16,0x6d9d6122)
　　　HH(b,c,d,a,M14,23,0xfde5380c)
　　　HH(a,b,c,d,M1,4,0xa4beea44)
　　　HH(d,a,b,c,M4,11,0x4bdecfa9)
　　　HH(c,d,a,b,M7,16,0xf6bb4b60)
　　　HH(b,c,d,a,M10,23,0xbebfbc70)
　　　HH(a,b,c,d,M13,4,0x289b7ec6)
　　　HH(d,a,b,c,M0,11,0xeaa127fa)
　　　HH(c,d,a,b,M3,16,0xd4ef3085)
　　　HH(b,c,d,a,M6,23,0x04881d05)
　　　HH(a,b,c,d,M9,4,0xd9d4d039)
　　　HH(d,a,b,c,M12,11,0xe6db99e5)
　　　HH(c,d,a,b,M15,16,0x1fa27cf8)
　　　HH(b,c,d,a,M2,23,0xc4ac5665)
　　第四轮
　　　II(a,b,c,d,M0,6,0xf4292244)
　　　II(d,a,b,c,M7,10,0x432aff97)
　　　II(c,d,a,b,M14,15,0xab9423a7)
　　　II(b,c,d,a,M5,21,0xfc93a039)
　　　II(a,b,c,d,M12,6,0x655b59c3)
　　　II(d,a,b,c,M3,10,0x8f0ccc92)
　　　II(c,d,a,b,M10,15,0xffeff47d)
　　　II(b,c,d,a,M1,21,0x85845dd1)
　　　II(a,b,c,d,M8,6,0x6fa87e4f)
　　　II(d,a,b,c,M15,10,0xfe2ce6e0)
　　　II(c,d,a,b,M6,15,0xa3014314)
　　　II(b,c,d,a,M13,21,0x4e0811a1)
　　　II(a,b,c,d,M4,6,0xf7537e82)
　　　II(d,a,b,c,M11,10,0xbd3af235)
　　　II(c,d,a,b,M2,15,0x2ad7d2bb)
　　　II(b,c,d,a,M9,21,0xeb86d391)
　　常数ti可以如下选择：
　　在第i步中，ti是4294967296*abs(sin(i))的整数部分，i的单位是弧度。(4294967296等于2的32次方)所有这些完成之后，将A、B、C、D分别加上a、b、c、d。然后用下一分组数据继续运行算法，
最后的输出是A、B、C和D的级联。
　　当你按照我上面所说的方法实现MD5算法以后，你可以用以下几个信息对你做出来的程序作一个简单的测试，看看程序有没有错误。
　　　MD5 ("") = d41d8cd98f00b204e9800998ecf8427e
　　　MD5 ("a") = 0cc175b9c0f1b6a831c399e269772661
　　　MD5 ("abc") = 900150983cd24fb0d6963f7d28e17f72
　　　MD5 ("message digest") = f96b697d7cb7938d525a2f31aaf161d0
　　　MD5 ("abcdefghijklmnopqrstuvwxyz") = c3fcd3d76192e4007dfb496cca67e13b
　　　MD5 ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") =
d174ab98d277d9f5a5611c2c9f419d9f
　　　MD5 ("123456789012345678901234567890123456789012345678901234567890123456789
01234567890") = 57edf4a22be3c955ac49da2e2107b67a
　　MD5的安全性
　　MD5相对MD4所作的改进：
　　　1. 增加了第四轮；
　　　2. 每一步均有唯一的加法常数；
　　　3. 为减弱第二轮中函数G的对称性从(X&Y)|(X&Z)|(Y&Z)变为(X&Z)|(Y&(~Z))；
　　　4. 第一步加上了上一步的结果，这将引起更快的雪崩效应；
　　　5. 改变了第二轮和第三轮中访问消息子分组的次序，使其更不相&#20284;；
　　　6. 近&#20284;优化了每一轮中的循环左移位移量以实现更快的雪崩效应。各轮的位移量互不相同。
3. RSA算法
RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。 RSA的算法涉及三个参数，n、e1、e2。 其中，n是两个大质数p、q的积，n的二进制表示时所占用的位数，就是所谓的密钥长度。 e1和e2是一对相关的&#20540;，e1可以任意取，但要求e1与(p-1)*(q-1)互质；再选择e2，要求
(e2*e1)mod((p-1)*(q-1))=1。
(n及e1),(n及e2)就是密钥对。
RSA加解密的算法完全相同,设A为明文，B为密文，则：A=B^e1 mod n；B=A^e2 mod n；
e1和e2可以互换使用，即：
A=B^e2 mod n；B=A^e1 mod n；
补充：
对明文进行加密，有两种情况需要这样作：
1、您向朋友传送加密数据，您希望只有您的朋友可以解密，这样的话，您需要首先获取您朋友的密钥对中公开的那一个密钥，e及n。然后用这个密钥进行加密，这样密文只有您的朋友可以解密，因为对应的私钥只有您朋友拥有。
2、您向朋友传送一段数据附加您的数字签名，您需要对您的数据进行MD5之类的运算以取得数据的"指纹"，再对"指纹"进行加密，加密将使用您自己的密钥对中的不公开的私钥。您的朋友收到数据后，用同样的运算获得数据指纹，再用您的公钥对加密指纹进行解密，比较解密结果与他自己计算出来的指纹是否一致，即可确定数据是否的确是您发送的、以及在传输过程中是否被篡改。
密钥的获得，通常由某个机构颁发（如CA中心），当然也可以由您自己创建密钥，但这样作，
您的密钥并不具有权威性。
计算方面，按公式计算就行了，如果您的加密强度为1024位，则结果会在有效数据前面补0以补齐不足的位数。补入的0并不影响解密运算。
4. DES算法
DES(Data Encryption Standard)满足了国家标准局欲达到的4个目的:提供高质量的数据保护，防止数据未经授权的泄露和未被察觉的修改；具有相当高的复杂性，使得破译的开销超过可能获得的利益，同时又要便于理解和掌握；
DES算法把64位的明文输入块变为64位的密文输出块，它所使用的密钥也是64位，首先，DES把输入的64位数据块按位重新组合，并把输出分为L0、R0两部分，每部分各长32位，并进行前后置换（输入的第58位换到第一位，第50位换到第2位，依此类推，最后一位是原来的第7位），最终由L0输出左32位，R0输出右32位，根据这个法则经过16次迭代运算后，得到L16、R16，将此作为输入，进行与初始置换相反的逆置换，即得到密文输出。
DES算法的入口参数有三个：Key、Data、Mode。其中Key为8个字节共64位，是DES算法的工作密钥；Data也为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式，有两种：加密或解密，如果Mode为加密，则用Key去把数据Data进行加密，生成Data的密码形式作为DES的输出结果；如Mode为解密，则用Key去把密码形式的数据Data解密，还原为Data的明码形式作为DES的输出结果。在使用DES时，双方预先约定使用的”密码”即Key，然后用Key去加密数据；接收方得到密文后使用同样的Key解密得到原数据，这样便实现了安全性较高的数据传输。
